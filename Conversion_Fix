//Issue 1

outputLen := make([]byte, 4)
binary.LittleEndian.PutUint32(outputLen, uint32(textGenerationInput.OutputLen))

// Add an upper-bound check for TopK
const maxUint32 = math.MaxUint32
if textGenerationInput.TopK > maxUint32 {
    textGenerationInput.TopK = maxUint32
}

topK := make([]byte, 4)
binary.LittleEndian.PutUint32(topK, uint32(textGenerationInput.TopK))

seed := make([]byte, 8)
binary.LittleEndian.PutUint64(seed, uint64(textGenerationInput.Seed))

modelInferRequest.RawInputContents = append(modelInferRequest.RawInputContents, SerializeBytesTensor([][]byte{[]byte(textGenerationInput.Prompt)}))

// Issue 2

case commonPB.Task_TASK_TEXT_GENERATION:
    textGenerationInput := inferInput.(*TextGenerationInput)

    // Correctly handle conversions with upper-bound checks
    outputLen := make([]byte, 4)
    if textGenerationInput.OutputLen > math.MaxUint32 {
        textGenerationInput.OutputLen = math.MaxUint32
    }
    binary.LittleEndian.PutUint32(outputLen, uint32(textGenerationInput.OutputLen))

    topK := make([]byte, 4)
    if textGenerationInput.TopK > math.MaxUint32 {
        textGenerationInput.TopK = math.MaxUint32
    }
    binary.LittleEndian.PutUint32(topK, uint32(textGenerationInput.TopK))

    seed := make([]byte, 8)
    if textGenerationInput.Seed > math.MaxUint64 {
        textGenerationInput.Seed = math.MaxUint64
    }
    binary.LittleEndian.PutUint64(seed, uint64(textGenerationInput.Seed))

//Issue 3

samples := make([]byte, 4)
if textToImageInput.Samples > math.MaxUint32 {
    textToImageInput.Samples = math.MaxUint32
}

binary.LittleEndian.PutUint32(samples, uint32(textToImageInput.Samples))

// Correctly handle the conversion with an upper-bound check
steps := make([]byte, 4)
if textToImageInput.Steps > math.MaxUint32 {
    textToImageInput.Steps = math.MaxUint32
}
binary.LittleEndian.PutUint32(steps, uint32(textToImageInput.Steps))

guidanceScale := make([]byte, 4)
if textToImageInput.CfgScale > math.MaxFloat32 {
    textToImageInput.CfgScale = math.MaxFloat32
}
binary.LittleEndian.PutUint32(guidanceScale, math.Float32bits(textToImageInput.CfgScale))

seed := make([]byte, 8)
if textToImageInput.Seed > math.MaxUint64 {
    textToImageInput.Seed = math.MaxUint64
}
binary.LittleEndian.PutUint64(seed, uint64(textToImageInput.Seed))
